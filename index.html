<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive 3D Head Tracking - Hallway Portal</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; color: #eee; }
        
        /* Main 3D Canvas */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI Overlays */
        #info {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            color: lime; font-family: monospace; background: rgba(0,0,0,0.5); padding: 5px 10px;
            pointer-events: none;
        }

        #webcam-preview {
            position: absolute; bottom: 10px; left: 10px; width: 160px; z-index: 10;
            border: 2px solid #555; transform: scaleX(-1); opacity: 0;
            border-radius: 8px;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5rem; z-index: 20; text-shadow: 0 0 10px black;
        }

        /* CONTROLS SIDEBAR */
        #controls-container {
            position: absolute; top: 10px; right: 10px; width: 250px;
            background: rgba(30, 30, 30, 0.9); padding: 20px; border-radius: 12px;
            z-index: 30; border: 1px solid #444; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9rem;}
        .val-display { float: right; color: lime; font-weight: normal;}
        input[type=range] { width: 100%; accent-color: lime; }
        
        /* Custom File Upload Styling */
        .custom-file-upload {
            display: block; width: 100%; padding: 10px;
            background: #333; border: 1px dashed #666;
            text-align: center; cursor: pointer; border-radius: 6px; transition: background 0.3s;
        }
        .custom-file-upload:hover { background: #444; border-color: lime; }
        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="loading">Initializing AI & GPU...</div>
    <div id="info">Waiting for face detection...</div>
    <video id="webcam-preview" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <div id="controls-container">
        <div class="control-group">
            <label>Screen Height (cm): <span id="fov-val" class="val-display">30</span></label>
            <input type="range" id="fov-slider" min="15" max="60" step="1" value="30">
            <small style="color:#aaa">Match this to your physical monitor height.</small>
        </div>

        <div class="control-group" style="border-top: 1px solid #444; padding-top: 20px;">
            <label>Tunnel Length: <span id="scale-val" class="val-display">1.0x</span></label>
            <input type="range" id="scale-slider" min="0.1" max="5" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label for="file-input" class="custom-file-upload">
                üìÅ Upload local STL file
            </label>
            <input id="file-input" type="file" accept=".stl" />
        </div>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { FilesetResolver, FaceLandmarker } from '@mediapipe/tasks-vision';

        // ==========================================
        // 1. GLOBAL STATE & CONFIG
        // ==========================================
        const CONFIG = {
            SCREEN_HEIGHT_CM: 30, // Default physical screen height
            REAL_IPD_CM: 6.4,     // Avg human IPD
            SMOOTHING: 0.15       // Lower = smoother, higher = faster
        };

        // Screen Dimensions (World Units)
        // We assume 1 World Unit = 1 CM
        let worldScreenWidth = 0;
        let worldScreenHeight = CONFIG.SCREEN_HEIGHT_CM;

        // Math helper variable
        // We use a fixed reference FOV for depth estimation logic
        let focalLengthNorm = 0.8; 

        // Mesh State
        let currentMesh = null;
        let scaleMultiplier = 1.0; 

        // ==========================================
        // 2. THREE.JS SETUP
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 2000);
        // Important: Camera rotation must stay at (0,0,0) for the window illusion
        camera.rotation.set(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.PointLight(0xffffff, 1.5, 1000);
        light.position.set(0, 0, 50); // Light near the viewer
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.2));

        scene.fog = new THREE.Fog(0x000000, 10, 800);

        const stlLoader = new STLLoader();
        const meshMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x00aaff, metalness: 0.5, roughness: 0.2, clearcoat: 1.0
        });

        // ==========================================
        // 3. UI & OBJECT MANAGEMENT
        // ==========================================

        // --- Helper: Update Screen Dimensions ---
        function updateScreenDimensions() {
            const aspect = window.innerWidth / window.innerHeight;
            worldScreenHeight = CONFIG.SCREEN_HEIGHT_CM;
            worldScreenWidth = worldScreenHeight * aspect;
            
            // Rebuild hallway when screen size changes to keep it "fitted"
            buildHallway(); 
        }

        // --- Helper: Build the Hallway Portal ---
        function buildHallway() {
            if (currentMesh) {
                scene.remove(currentMesh);
                currentMesh.traverse?.(o => { if (o.geometry) o.geometry.dispose(); });
            }

            // Dimensions derived from Screen Size
            const w = worldScreenWidth;
            const h = worldScreenHeight;
            const depth = 2000; 

            // Texture generation for a grid pattern
            const canvas = document.createElement('canvas');
            canvas.width = 512; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#111'; ctx.fillRect(0,0,512,512);
            ctx.strokeStyle = '#00ffaa'; ctx.lineWidth = 4;
            ctx.strokeRect(0,0,512,512); // border
            // cross
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(512,512); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(512,0); ctx.lineTo(0,512); ctx.stroke();
            
            const tex = new THREE.CanvasTexture(canvas);
            tex.wrapS = THREE.RepeatWrapping;
            tex.wrapT = THREE.RepeatWrapping;
            tex.repeat.set(1, 10); // Stretch down the hall

            const mat = new THREE.MeshStandardMaterial({ 
                map: tex, 
                side: THREE.BackSide, // Render INSIDE the box
                roughness: 0.4
            });

            // Create a Box that acts as the tunnel
            // Width/Height match screen exactly. Depth extends backwards.
            const geometry = new THREE.BoxGeometry(w, h, depth);
            
            // Shift geometry so the front face is at Z=0 and it goes to -depth
            geometry.translate(0, 0, -depth / 2);

            const tunnel = new THREE.Mesh(geometry, mat);
            currentMesh = tunnel;
            scene.add(tunnel);
        }
        
        // Use STLLoader logic (unchanged essentially, just positioning)
        function replaceMesh(geometry) {
             if(currentMesh) scene.remove(currentMesh);
             
             geometry.center();
             geometry.computeBoundingBox();
             const size = geometry.boundingBox.getSize(new THREE.Vector3());
             
             // Scale object to fit comfortably inside the screen height (approx 50%)
             const scale = (worldScreenHeight * 0.5) / size.y;
             
             currentMesh = new THREE.Mesh(geometry, meshMaterial);
             currentMesh.scale.set(scale, scale, scale);
             currentMesh.position.set(0, 0, -50); // Place it inside the screen
             scene.add(currentMesh);
        }

        // --- EVENT LISTENERS FOR UI ---

        // 1. SCREEN HEIGHT SLIDER (Replaces FOV)
        const fovSlider = document.getElementById('fov-slider');
        const fovDisplay = document.getElementById('fov-val');
        fovSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            CONFIG.SCREEN_HEIGHT_CM = val;
            fovDisplay.innerText = val;
            updateScreenDimensions();
        });

        // 2. DEPTH SCALE SLIDER
        const scaleSlider = document.getElementById('scale-slider');
        const scaleDisplay = document.getElementById('scale-val');
        scaleSlider.addEventListener('input', (e) => {
             const val = parseFloat(e.target.value);
             scaleDisplay.innerText = val.toFixed(1) + "x";
             if(currentMesh) currentMesh.scale.z = val; 
        });

        // 3. FILE UPLOAD
        const fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                 try {
                     const geometry = stlLoader.parse(event.target.result);
                     replaceMesh(geometry);
                 } catch (err) { console.error(err); }
            };
            reader.readAsArrayBuffer(file);
        });

        // --- INITIALIZATION ---
        updateScreenDimensions(); // Build initial hallway

        // ==========================================
        // 4. MEDIAPIPE LOGIC & MAIN LOOP
        // ==========================================
        const video = document.getElementById('webcam-preview');
        const infoDiv = document.getElementById('info');
        let faceLandmarker;
        
        // Track Head Position
        const currentHeadPos = new THREE.Vector3(0, 0, 60); // Start at 60cm distance
        const targetHeadPos = new THREE.Vector3(0, 0, 60);

        async function initVision() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numFaces: 1
            });
            
            document.getElementById('loading').style.display = 'none';
            navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: "user" } }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", renderLoop);
            });
        }

        // --- KEY LOGIC: OFF-AXIS PROJECTION ---
        // This makes the monitor behave like a window.
        function updateOffAxisProjection(camera, headPos) {
            // 1. Position camera exactly where the head is
            camera.position.copy(headPos);
            
            // 2. Calculate the frustum planes at the Screen Plane (Z=0)
            // The screen is located at Z=0. The camera is at Z=headPos.z.
            const near = 0.1; 
            const far = 5000;
            
            // Distance from eye to screen plane
            const dist = Math.abs(headPos.z); 
            
            // Ratio of NearPlane / ScreenPlane
            const ratio = near / dist;

            // Screen boundaries relative to the camera's X/Y position
            // Left edge of screen is at -worldScreenWidth/2.
            // Right edge is at +worldScreenWidth/2.
            // But these are relative to World Origin (0,0).
            // Relative to Camera (headPos.x), the Left edge is (-W/2 - headX).
            
            const left   = (-worldScreenWidth / 2 - headPos.x) * ratio;
            const right  = ( worldScreenWidth / 2 - headPos.x) * ratio;
            const top    = ( worldScreenHeight / 2 - headPos.y) * ratio;
            const bottom = (-worldScreenHeight / 2 - headPos.y) * ratio;

            // Apply the skewed projection matrix
            camera.projectionMatrix.makePerspective(left, right, top, bottom, near, far);
            
            // Note: camera.lookAt is NOT used. The camera forward vector remains parallel to Z axis.
        }

        let lastVideoTime = -1;

        function renderLoop() {
            // 1. Detect Face
            if (video.currentTime !== lastVideoTime && faceLandmarker) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, performance.now());

                if (results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];

                    // Standard Pupil detection for Z depth
                    const leftPupil = landmarks[468];
                    const rightPupil = landmarks[473];
                    const dx = (leftPupil.x - rightPupil.x);
                    const dy = (leftPupil.y - rightPupil.y);
                    const distScreen = Math.sqrt(dx*dx + dy*dy);
                    
                    // Note: "distScreen" here is raw normalized 0..1 distance.
                    // We approximate Z based on a calibrated constant (0.06 is roughly iris distance at 60cm)
                    // Simplified calibration:
                    const zCm = (0.065 / distScreen) * 60; // Rough estimator

                    // XY Calculation
                    // Center of screen is 0.5, 0.5
                    const midX = (leftPupil.x + rightPupil.x) / 2;
                    const midY = (leftPupil.y + rightPupil.y) / 2;

                    // Convert Normalized (0-1) to World CM (Screen Size)
                    // We flip X because webcam is mirrored
                    const xCm = -(midX - 0.5) * worldScreenWidth * (zCm / 60) * 1.5; 
                    const yCm = -(midY - 0.5) * worldScreenHeight * (zCm / 60) * 1.5;

                    targetHeadPos.set(xCm, yCm, zCm);
                    
                    infoDiv.innerText = `Head: ${xCm.toFixed(0)}, ${yCm.toFixed(0)}, ${zCm.toFixed(0)}cm`;
                }
            }

            // 2. Smooth Movement
            currentHeadPos.lerp(targetHeadPos, CONFIG.SMOOTHING);

            // 3. Update Camera using Off-Axis Projection
            updateOffAxisProjection(camera, currentHeadPos);

            renderer.render(scene, camera);
            requestAnimationFrame(renderLoop);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateScreenDimensions(); // Recalculate Hallway size
        });

        initVision();
    </script>
</body>
</html>
