<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Interactive 3D Head Tracking</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; font-family: sans-serif; color: #eee; }
        
        /* Main 3D Canvas */
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }

        /* UI Overlays */
        #info {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            color: lime; font-family: monospace; background: rgba(0,0,0,0.5); padding: 5px 10px;
            pointer-events: none;
        }

        #webcam-preview {
            position: absolute; bottom: 10px; left: 10px; width: 160px; z-index: 10;
            border: 2px solid #555; transform: scaleX(-1); opacity: 0;
            border-radius: 8px;
        }

        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: white; font-size: 1.5rem; z-index: 20; text-shadow: 0 0 10px black;
        }

        /* CONTROLS SIDEBAR */
        #controls-container {
            position: absolute; top: 10px; right: 10px; width: 250px;
            background: rgba(30, 30, 30, 0.9); padding: 20px; border-radius: 12px;
            z-index: 30; border: 1px solid #444; box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }
        .control-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 5px; font-weight: bold; font-size: 0.9rem;}
        .val-display { float: right; color: lime; font-weight: normal;}
        input[type=range] { width: 100%; accent-color: lime; }
        
        /* Custom File Upload Styling */
        .custom-file-upload {
            display: block; width: 100%; padding: 10px;
            background: #333; border: 1px dashed #666;
            text-align: center; cursor: pointer; border-radius: 6px; transition: background 0.3s;
        }
        .custom-file-upload:hover { background: #444; border-color: lime; }
        #file-input { display: none; }
    </style>
</head>
<body>

    <div id="loading">Initializing AI & GPU...</div>
    <div id="info">Waiting for face detection...</div>
    <video id="webcam-preview" autoplay playsinline muted></video>
    <div id="canvas-container"></div>

    <div id="controls-container">
        <div class="control-group">
            <label>Webcam Vertical FOV: <span id="fov-val" class="val-display">55¬∞</span></label>
            <input type="range" id="fov-slider" min="30" max="80" step="1" value="55">
            <small style="color:#aaa">Adjust until depth movement feels realistic.</small>
        </div>

        <div class="control-group" style="border-top: 1px solid #444; padding-top: 20px;">
            <label>Object Scale Multiplier: <span id="scale-val" class="val-display">1.0x</span></label>
            <input type="range" id="scale-slider" min="0.1" max="10" step="0.1" value="1.0">
        </div>

        <div class="control-group">
            <label for="file-input" class="custom-file-upload">
                üìÅ Upload local STL file
            </label>
            <input id="file-input" type="file" accept=".stl" />
        </div>
    </div>


    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/+esm"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { STLLoader } from 'three/addons/loaders/STLLoader.js';
        import { FilesetResolver, FaceLandmarker } from '@mediapipe/tasks-vision';

        // ==========================================
        // 1. GLOBAL STATE & CONFIG
        // ==========================================
        const CONFIG = {
            WEBCAM_FOV_Y: 55,     // Updated by slider
            REAL_IPD_CM: 6.4,     // Avg human IPD
            SMOOTHING: 0.5
        };

        // Math helper variable (calculated later)
        let focalLengthNorm = 0;

        // Mesh State
        let currentMesh = null;
        let baseNormalizedScale = 1.0; // Scale required to make object 10cm wide initially
        let scaleMultiplier = 1.0;     // Value from slider (0.1x to 10x)

        // ==========================================
        // 2. THREE.JS SETUP
        // ==========================================
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const camera = new THREE.PerspectiveCamera(CONFIG.WEBCAM_FOV_Y, window.innerWidth / window.innerHeight, 0.1, 2000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // Lighting
        const light = new THREE.DirectionalLight(0xffffff, 2);
        light.position.set(10, 20, 15);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0xffffff, 0.4));

        // Helper Grid (1 unit = 1cm) -> 50cm grid
        // const grid = new THREE.GridHelper(100, 100, 0x333333, 0x222222);
        // scene.add(grid);
        
        // Add Axes helper at origin
        // scene.add(new THREE.AxesHelper(10));

        scene.fog = new THREE.FogExp2(0x000000, 0.0025);

        const stlLoader = new STLLoader();
        const meshMaterial = new THREE.MeshPhysicalMaterial({
            color: 0x00aaff, metalness: 0.2, roughness: 0.3, clearcoat: 0.5
        });

        let hallwayGroup = null;
        let isHallway = false;
        let hallwayDepthScale = 1; // driven by the existing scale slider for Z only
        
        const HALLWAY = {
          baseWidth: 1,   // base inner width at the entrance (cm, arbitrary base)
          baseHeight: 1,  // base inner height at the entrance (cm, arbitrary base)
          length: 2000    // tunnel depth in cm (20 m)
        };

        // ==========================================
        // 3. UI & OBJECT MANAGEMENT
        // ==========================================

        // --- Helper: Recalculate Physics Math based on FOV ---
        function updateFocalLengthMath() {
             const fovRad = (CONFIG.WEBCAM_FOV_Y * Math.PI) / 180;
             // focal_length = 0.5 / tan(FOV/2)
             focalLengthNorm = 0.5 / Math.tan(fovRad / 2);
        }

        // --- Helper: Replace current mesh in scene ---
        function replaceMesh(geometry) {
            isHallway = false;
            hallwayGroup = null;
            if(currentMesh) {
                scene.remove(currentMesh);
                currentMesh.geometry.dispose();
            }

            geometry.center();
            geometry.computeBoundingBox();
            geometry.computeVertexNormals(); // Ensure smooth lighting

            // 1. Calculate Base Normalization Scale (make it ~10cm wide initially)
            const width = geometry.boundingBox.max.x - geometry.boundingBox.min.x;
            
            baseNormalizedScale = 1;

            currentMesh = new THREE.Mesh(geometry, meshMaterial);
            
            // STL standard orientation fix
            currentMesh.rotation.x = -Math.PI / 2; 

            scene.add(currentMesh);
            // Apply current slider scale instantly
            applyCurrentScale();
        }

        // --- Helper: Apply slider scale to base scale ---
        function applyCurrentScale() {
            if(!currentMesh) return;
            const finalScale = baseNormalizedScale * scaleMultiplier;
            currentMesh.scale.set(finalScale, finalScale, finalScale);
        }


        // --- EVENT LISTENERS FOR UI ---

        // 1. FOV SLIDER
        const fovSlider = document.getElementById('fov-slider');
        const fovDisplay = document.getElementById('fov-val');
        fovSlider.addEventListener('input', (e) => {
            const val = parseInt(e.target.value);
            CONFIG.WEBCAM_FOV_Y = val;
            fovDisplay.innerText = val + "¬∞";
            
            // Update ThreeJS Camera
            camera.fov = val;
            camera.updateProjectionMatrix();
            
            // Update Physics Math
            updateFocalLengthMath();
        });

        // 2. SCALE SLIDER
        const scaleSlider = document.getElementById('scale-slider');
        const scaleDisplay = document.getElementById('scale-val');
        scaleSlider.addEventListener('input', (e) => {
             scaleMultiplier = parseFloat(e.target.value);
             scaleDisplay.innerText = scaleMultiplier.toFixed(1) + "x";
             applyCurrentScale();
        });

        // 3. FILE UPLOAD BUTTON
        const fileInput = document.getElementById('file-input');
        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                 try {
                     const geometry = stlLoader.parse(event.target.result);
                     replaceMesh(geometry);
                     // Reset scale slider for new object interaction
                     scaleMultiplier = 1.0;
                     scaleSlider.value = 1.0;
                     scaleDisplay.innerText = "1.0x";
                 } catch (err) {
                     alert("Error parsing STL file. It might be corrupted or wrong format.");
                     console.error(err);
                 }
            };
            reader.readAsArrayBuffer(file);
        });

        // --- INITIALIZATION ---
        updateFocalLengthMath(); // Init math based on default slider value
        
        // Load initial fallback cube

        // Build a 4-sided corridor that starts exactly at z=0 and goes to negative Z
        function buildHallway() {
          // Clean any existing mesh/group
          if (currentMesh) {
            scene.remove(currentMesh);
            currentMesh.traverse?.(o => { if (o.geometry) o.geometry.dispose(); });
          }
        
          const w = HALLWAY.baseWidth;
          const h = HALLWAY.baseHeight;
          const L = HALLWAY.length;
        
          const mat = new THREE.MeshStandardMaterial({
            color: 0x2a2a2a,
            roughness: 0.95,
            metalness: 0.0,
            side: THREE.DoubleSide
          });
        
          const group = new THREE.Group();
        
          // Floor
          const floor = new THREE.Mesh(new THREE.PlaneGeometry(w, L), mat);
          floor.rotation.x = -Math.PI / 2;        // XY -> XZ
          floor.position.set(0, -h / 2, -L / 2);  // front edge at z=0, extends to -L
          group.add(floor);
        
          // Ceiling
          const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(w, L), mat);
          ceiling.rotation.x = -Math.PI / 2;
          ceiling.position.set(0, h / 2, -L / 2);
          group.add(ceiling);
        
          // Left wall
          const left = new THREE.Mesh(new THREE.PlaneGeometry(L, h), mat);
          left.rotation.y = Math.PI / 2;          // XY -> ZY
          left.position.set(-w / 2, 0, -L / 2);
          group.add(left);
        
          // Right wall
          const right = new THREE.Mesh(new THREE.PlaneGeometry(L, h), mat);
          right.rotation.y = -Math.PI / 2;
          right.position.set(w / 2, 0, -L / 2);
          group.add(right);

          group.position.y -= 10
          group.scale.setScalar(5);
        
          hallwayGroup = group;
          currentMesh = group;
            
          isHallway = true;
          baseNormalizedScale = 1; // not used for hallway X/Y (we drive those dynamically)
          scene.add(group);
        }

        // const initialGeo = new THREE.BoxGeometry(10, 10, 10);
        // replaceMesh(initialGeo);

        buildHallway()


        // ==========================================
        // 4. MEDIAPIPE LOGIC & MAIN LOOP
        // ==========================================
        const video = document.getElementById('webcam-preview');
        const infoDiv = document.getElementById('info');
        let faceLandmarker;
        const currentPos = new THREE.Vector3(0, 0, 60);
        const targetPos = new THREE.Vector3(0, 0, 60);

        async function initVision() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
            faceLandmarker = await FaceLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numFaces: 1
            });
            
            document.getElementById('loading').style.display = 'none';
            
            navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480, facingMode: "user" } }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", renderLoop);
            });
        }

        let lastVideoTime = -1;

        function renderLoop() {
            // 1. Detect Face
            if (video.currentTime !== lastVideoTime && faceLandmarker) {
                lastVideoTime = video.currentTime;
                const results = faceLandmarker.detectForVideo(video, performance.now());

                if (results.faceLandmarks.length > 0) {
                    const landmarks = results.faceLandmarks[0];

                    // Pupils: 468 (Left), 473 (Right)
                    const leftPupil = landmarks[468];
                    const rightPupil = landmarks[473];
                    const aspect = video.videoWidth / video.videoHeight;
                    
                    // Distance between pupils in normalized screen units
                    const dx = (leftPupil.x - rightPupil.x) * aspect;
                    const dy = (leftPupil.y - rightPupil.y);
                    const distScreen = Math.sqrt(dx*dx + dy*dy);

                    // Pinhole Z Calculation
                    const zCm = (CONFIG.REAL_IPD_CM * focalLengthNorm) / distScreen;

                    // Midpoint in normalized screen coords
                    const midX = (leftPupil.x + rightPupil.x) / 2;
                    const midY = (leftPupil.y + rightPupil.y) / 2;

                    // Center coordinates [-0.5, 0.5] and flip X
                    const xScreen = (0.5 - midX) * aspect; 
                    const yScreen = (0.5 - midY);

                    // Project screen coords to world coords
                    const xCm = (xScreen * zCm) / focalLengthNorm;
                    const yCm = (yScreen * zCm) / focalLengthNorm;

                    targetPos.set(xCm, yCm, zCm);
                    
                    infoDiv.innerText = `Head Pos: X:${xCm.toFixed(0)} Y:${yCm.toFixed(0)} Z:${zCm.toFixed(0)} cm`;
                }
            }

            // 2. Smooth Movement
            currentPos.lerp(targetPos, CONFIG.SMOOTHING);

            // 3. Update Camera
            camera.position.copy(currentPos);
            camera.lookAt(0, -10, 0);

            renderer.render(scene, camera);
            requestAnimationFrame(renderLoop);
        }

        // Handle Window Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        initVision();
    </script>
</body>
</html>
