<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three-Point Perspective Cube (Free VPs)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 12px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            max-width: 1200px;
            width: 100%;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        h1 { font-size: 24px; margin-bottom: 8px; }
        .subtitle { opacity: 0.9; font-size: 14px; }
        .canvas-container {
            position: relative;
            background: #f8f9fa;
            border-bottom: 2px solid #e9ecef;
        }
        canvas { display: block; cursor: crosshair; }
        .controls { padding: 24px; background: white; }
        .control-group { margin-bottom: 20px; }
        .control-group:last-child { margin-bottom: 0; }
        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #495057;
            font-size: 14px;
        }
        .slider-container { display: flex; align-items: center; gap: 12px; }
        input[type="range"] {
            flex: 1; height: 6px; border-radius: 3px; background: #e9ecef;
            outline: none; -webkit-appearance: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 18px; height: 18px; border-radius: 50%;
            background: #667eea; cursor: pointer; transition: transform 0.2s;
        }
        input[type="range"]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        input[type="range"]::-moz-range-thumb {
            width: 18px; height: 18px; border-radius: 50%;
            background: #667eea; cursor: pointer; border: none;
        }
        .value-display {
            min-width: 50px; text-align: right; font-weight: 600;
            color: #667eea; font-size: 14px;
        }
        .controls-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
        }
        .info {
            background: #e7f5ff; padding: 12px; border-radius: 6px;
            font-size: 13px; color: #1864ab; margin-top: 16px;
        }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <h1>Three-Point Perspective Cube</h1>
        <div class="subtitle">Drag the three vanishing points and the base corner â€¢ Adjust edge extents</div>
    </div>

    <div class="canvas-container">
        <canvas id="canvas" width="1200" height="700"></canvas>
    </div>

    <div class="controls">
        <div class="controls-grid">
            <div class="control-group">
                <label>Extent toward VP1 (a)</label>
                <div class="slider-container">
                    <input type="range" id="sideA" min="30" max="400" value="150">
                    <span class="value-display" id="valueA">150</span>
                </div>
            </div>

            <div class="control-group">
                <label>Extent toward VP3 (b)</label>
                <div class="slider-container">
                    <input type="range" id="sideB" min="30" max="400" value="150">
                    <span class="value-display" id="valueB">150</span>
                </div>
            </div>

            <div class="control-group">
                <label>Extent toward VP2 (c)</label>
                <div class="slider-container">
                    <input type="range" id="sideC" min="30" max="400" value="150">
                    <span class="value-display" id="valueC">150</span>
                </div>
            </div>
        </div>

        <div class="info">
            Tip: The three vanishing points are independent and always stay within the canvas. The cube is constructed from the base corner (purple) by extending along lines toward each VP by the chosen extents, then completing the box using line intersections.
        </div>
    </div>
</div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // State
    const state = {
        a: 150, // extent toward VP1
        b: 150, // extent toward VP3
        c: 150, // extent toward VP2
        // Base corner (anchor) of the cube
        anchor: { x: canvas.width / 2, y: canvas.height / 2 + 60 },
        // Vanishing points (kept inside canvas)
        vp1: { x: 250, y: 360 }, // red
        vp2: { x: 950, y: 360 }, // blue
        vp3: { x: 600, y: 140 }, // green
        dragging: null
    };

    // Utilities
    function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
    function clampPoint(p) {
        return {
            x: clamp(p.x, 8, canvas.width - 8),
            y: clamp(p.y, 8, canvas.height - 8)
        };
    }
    function getMousePos(e) {
        const r = canvas.getBoundingClientRect();
        return { x: e.clientX - r.left, y: e.clientY - r.top };
    }
    function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

    function normalize(vx, vy) {
        const len = Math.hypot(vx, vy);
        if (len < 1e-6) return { x: 0, y: 0 };
        return { x: vx / len, y: vy / len };
    }

    // Line intersection: p1 + t*d1 with p2 + u*d2
    function intersect(p1, d1, p2, d2) {
        const x1 = p1.x, y1 = p1.y;
        const x2 = p1.x + d1.x, y2 = p1.y + d1.y;
        const x3 = p2.x, y3 = p2.y;
        const x4 = p2.x + d2.x, y4 = p2.y + d2.y;

        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
        if (Math.abs(denom) < 1e-6) return null;

        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;
        return { x: x1 + t * (x2 - x1), y: y1 + t * (y2 - y1) };
    }

    function dirToVP(from, vp) {
        return { x: vp.x - from.x, y: vp.y - from.y };
    }

    function drawCube() {
        const p1 = state.anchor;

        // Build three rays toward VPs
        let d1n = normalize(state.vp1.x - p1.x, state.vp1.y - p1.y);
        let d2n = normalize(state.vp2.x - p1.x, state.vp2.y - p1.y);
        let d3n = normalize(state.vp3.x - p1.x, state.vp3.y - p1.y);

        // If any VP is too close to p1, nudge directions
        if (d1n.x === 0 && d1n.y === 0) d1n = { x: 1, y: 0 };
        if (d2n.x === 0 && d2n.y === 0) d2n = { x: 0, y: 1 };
        if (d3n.x === 0 && d3n.y === 0) d3n = { x: -1, y: 0 };

        // Step along each ray by image extents a,b,c
        const p2 = { x: p1.x + d1n.x * state.a, y: p1.y + d1n.y * state.a }; // toward VP1
        const p4 = { x: p1.x + d2n.x * state.c, y: p1.y + d2n.y * state.c }; // toward VP2
        const p5 = { x: p1.x + d3n.x * state.b, y: p1.y + d3n.y * state.b }; // toward VP3

        // Complete the box with intersections (keeping parallels meeting at the same VP)
        const p3 = intersect(p2, dirToVP(p2, state.vp2), p4, dirToVP(p4, state.vp1));
        const p6 = intersect(p5, dirToVP(p5, state.vp1), p2, dirToVP(p2, state.vp3));
        const p8 = intersect(p5, dirToVP(p5, state.vp2), p4, dirToVP(p4, state.vp3));
        const p7 = p6 && p8
            ? intersect(p6, dirToVP(p6, state.vp2), p8, dirToVP(p8, state.vp1))
            : null;

        const verts = [p1, p2, p3, p4, p5, p6, p7, p8];
        if (verts.some(v => !v)) {
            // Degenerate configuration; draw what we can (guides and points)
            return;
        }

        // Edges of a cuboid
        const edges = [
            [0,1],[1,2],[2,3],[3,0], // bottom face loop
            [4,5],[5,6],[6,7],[7,4], // top face loop
            [0,4],[1,5],[2,6],[3,7]  // verticals
        ];

        // Draw faces with very light fill to keep overlap subtle
        const faces = [
            [0,1,2,3],
            [4,5,6,7],
            [0,1,5,4],
            [1,2,6,5],
            [2,3,7,6],
            [3,0,4,7]
        ];
        faces.forEach(face => {
            ctx.beginPath();
            ctx.moveTo(verts[face[0]].x, verts[face[0]].y);
            for (let i = 1; i < face.length; i++) ctx.lineTo(verts[face[i]].x, verts[face[i]].y);
            ctx.closePath();
            ctx.fillStyle = 'rgba(102,126,234,0.08)';
            ctx.fill();
        });

        // Draw edges
        ctx.lineWidth = 2.2;
        ctx.strokeStyle = '#2c3e50';
        edges.forEach(([i,j]) => {
            ctx.beginPath();
            ctx.moveTo(verts[i].x, verts[i].y);
            ctx.lineTo(verts[j].x, verts[j].y);
            ctx.stroke();
        });

        // Draw the base corner handle
        ctx.beginPath();
        ctx.arc(p1.x, p1.y, 7, 0, Math.PI * 2);
        ctx.fillStyle = '#8e44ad';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'white';
        ctx.stroke();
    }

    function drawGuides() {
        // Dashed guides from anchor to VPs
        const p = state.anchor;
        ctx.setLineDash([5, 5]);
        ctx.lineWidth = 1;
        ctx.strokeStyle = '#dee2e6';

        [state.vp1, state.vp2, state.vp3].forEach(vp => {
            ctx.beginPath();
            ctx.moveTo(p.x, p.y);
            ctx.lineTo(vp.x, vp.y);
            ctx.stroke();
        });
        ctx.setLineDash([]);

        // Draw VPs
        const vps = [
            { pos: state.vp1, color: '#e74c3c', label: 'VP1' },
            { pos: state.vp2, color: '#3498db', label: 'VP2' },
            { pos: state.vp3, color: '#2ecc71', label: 'VP3' }
        ];
        vps.forEach(vp => {
            ctx.beginPath();
            ctx.arc(vp.pos.x, vp.pos.y, 9, 0, Math.PI * 2);
            ctx.fillStyle = vp.color;
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = 'white';
            ctx.stroke();

            ctx.fillStyle = '#2c3e50';
            ctx.font = 'bold 12px sans-serif';
            ctx.fillText(vp.label, vp.pos.x + 12, vp.pos.y - 12);
        });
    }

    function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGuides();
        drawCube();
    }

    // Interaction
    canvas.addEventListener('mousedown', (e) => {
        const pos = getMousePos(e);
        if (dist(pos, state.vp1) < 14) state.dragging = 'vp1';
        else if (dist(pos, state.vp2) < 14) state.dragging = 'vp2';
        else if (dist(pos, state.vp3) < 14) state.dragging = 'vp3';
        else if (dist(pos, state.anchor) < 10) state.dragging = 'anchor';
    });

    canvas.addEventListener('mousemove', (e) => {
        if (!state.dragging) return;
        const pos = clampPoint(getMousePos(e));
        state[state.dragging] = pos;
        draw();
    });

    canvas.addEventListener('mouseup', () => { state.dragging = null; });
    canvas.addEventListener('mouseleave', () => { state.dragging = null; });

    // Controls
    const inputs = {
        a: document.getElementById('sideA'),
        b: document.getElementById('sideB'),
        c: document.getElementById('sideC'),
    };
    const displays = {
        a: document.getElementById('valueA'),
        b: document.getElementById('valueB'),
        c: document.getElementById('valueC'),
    };

    inputs.a.addEventListener('input', (e) => {
        state.a = parseInt(e.target.value, 10);
        displays.a.textContent = state.a;
        draw();
    });
    inputs.b.addEventListener('input', (e) => {
        state.b = parseInt(e.target.value, 10);
        displays.b.textContent = state.b;
        draw();
    });
    inputs.c.addEventListener('input', (e) => {
        state.c = parseInt(e.target.value, 10);
        displays.c.textContent = state.c;
        draw();
    });

    // Initial draw
    draw();
</script>
</body>
</html>
